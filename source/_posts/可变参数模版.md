---
title: 可变参数模版
date: 2025-10-10 14:53:51
categories: cpp
---

# 基本语法

```cpp
template<typename... Args>
void func(Args... args){
    
}
```

# 核心概念

- 参数包

  包含多个参数的模版参数

- 包展开

  解包参数的机制

# 展开参数包的四种方法

1. 递归展开

   ```cpp
   void print(){}
   
   template<typename T,typename... Args>
   void print(T first,Args... rest){
       std::cout<<first<<" ";
       print(rest...);
   }
   ```

2. 折叠表达式

   ```cpp
   template<typename... Args>
   auto sum(Args... args){
       return (...+args)
   }
   ```

3. 初始化列表

   代码解释：

   - 初始化列表用到了逗号运算符，相当于运行逗号左边的，输出逗号右边的东西。这个0随便取的，取任意值都可以。
   - 使用(void)是为了抑制编译期警告，因为我们用不到这个初始化列表，只是为了cout

   ```cpp
   template<typename... Args>
   void printall(Args... args){
       (void)std::initializer_list<int>{
         std::cout<<args<<" ",0)...  
       };
   }
   ```

4. lambda

   代码解释：

   这个使用到了lambda立即调用技巧，举例如下：

   ```cpp
   // 假设调用：process(1, "hello", 3.14);
   
   // 展开后相当于：
   [](auto&& x1, auto&& x2, auto&& x3){
       // 处理 x1, x2, x3
   }(1, "hello", 3.14);  // 立即用参数调用 lambda
   
   
   ```

   

   ```cpp
   tmplate<typename... Args>
   void process(Args&&... args){
       [](auto&&... xs){
           
       }(std::forward<Args>(args)...);
   }
   ```

# 高级用法

这里介绍完美转发和参数过滤

## 完美转发

```cpp
// 示例1：转发给 printf
template<typename... Args>
void wrapper(Args&&... args) {
    printf(std::forward<Args>(args)...);  // target_function = printf
}

// 使用
wrapper("Value: %d, Name: %s\n", 42, "Alice");

// 展开后相当于：
printf("Value: %d, Name: %s\n", 42, "Alice");

```

## 参数过滤

```cpp
template<typename T>
constexpr bool is_integer = std::is_integral_v<T>;

template<typename... Args>
auto filter_integers(Args... args){
    std::vector<int> result;
    (void)std::initializer_list<int>{
        (is_integer<decltype(args)>?(result.push_back(args),0):0)...
    };
    return results;
}
```
