---
title: 多态类型简述
date: 2025-10-11 11:01:13
categories: cpp
---

C++多态主要分为静态多态和动态多态

# 静态多态（编译时多态）

## 函数重载

```cpp
class Calculator {
public:
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
    int add(int a, int b, int c) { return a + b + c; }
};

// 编译器根据参数类型和数量选择合适的函数
Calculator calc;
calc.add(1, 2);        // 调用int版本
calc.add(1.5, 2.5);    // 调用double版本
```

## 运算符重载

```cpp
class Complex {
private:
    double real, imag;
public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}
    
    Complex operator+(const Complex& other) {
        return Complex(real + other.real, imag + other.imag);
    }
};

Complex c1(1, 2), c2(3, 4);
Complex c3 = c1 + c2;  // 使用重载的+运算符

```

## 模版多态

```cpp
template<typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

int result1 = max(1, 2);        // T=int
double result2 = max(1.5, 2.5); // T=double
```

# 动态多态（运行时多态）

## 虚函数多态

```cpp
class Animal {
public:
    virtual void makeSound() {
        cout << "Animal makes sound" << endl;
    }
    virtual ~Animal() = default;  // 虚析构函数
};

class Dog : public Animal {
public:
    void makeSound() override {
        cout << "Dog barks" << endl;
    }
};

class Cat : public Animal {
public:
    void makeSound() override {
        cout << "Cat meows" << endl;
    }
};

// 运行时多态的使用
Animal* animals[] = {new Dog(), new Cat()};
for(int i = 0; i < 2; i++) {
    animals[i]->makeSound();  // 根据实际对象类型调用相应函数
}
```

## 虚函数调用的地址如何解析

通过虚函数表（vtable）解析。当类中有虚函数时，编译器会为每个包含虚函数的类创建一个虚函数表，并在每个对象中添加一个虚函数表指针。

这个指针的地址其实就是对象地址，所以我们实际上可以通过这个指针调用虚函数。

```cpp
    typedef void (*FuncPtr)();
    // 手动模拟虚函数调用过程
    std::cout << "\n=== 手动模拟虚函数调用 ===" << std::endl;
    uintptr_t* vptr = reinterpret_cast<uintptr_t*>(derived);
    uintptr_t* vtable = reinterpret_cast<uintptr_t*>(*vptr);
    FuncPtr func = reinterpret_cast<FuncPtr>(vtable[0]); // func1的地址
```
