---
title: 智能指针简述
date: 2025-10-11 11:07:03
categories: cpp
---

# 指针指针类型

## unique_ptr

```cpp
#include <memory>

// 创建
auto ptr = std::make_unique<int>(42);
std::unique_ptr<int> ptr2(new int(100));

// 转移所有权
std::unique_ptr<int> ptr3 = std::move(ptr);  // ptr变为空

// 访问
*ptr3 = 200;        // 解引用
ptr3->someMethod(); // 成员访问
ptr3.get();         // 获取原始指针
```

## shared_ptr

```cpp
// 创建
auto ptr = std::make_shared<int>(42);
std::shared_ptr<int> ptr2(new int(100));  // 不推荐

// 共享所有权
auto ptr3 = ptr;  // 引用计数+1

// 检查引用计数
cout << ptr.use_count();  // 输出当前引用数
```

## weak_ptr

```cpp
std::shared_ptr<int> shared = std::make_shared<int>(42);
std::weak_ptr<int> weak = shared;  // 不增加引用计数

// 安全访问
if(auto locked = weak.lock()) {  // 检查对象是否还存在
    cout << *locked << endl;
}
```

# 其他

## shared_from_this

### 作用

1. std::enable_shared_from_this 类模板：

    - 它是一个基类模板，用于继承。当一个类继承自 `std::enable_shared_from_this<T>`时，它就具备了安全地从成员函数中返回 this 指针的能力，而不会导致双重删除或悬空指针的问题。
    - 它内部维护了一个弱引用（std::weak_ptr），这个弱引用会在第一个 `std::shared_ptr` 指向对象时被自动设置。

2. shared_from_this() 成员函数：
   - 这是 std::enable_shared_from_this 提供的成员函数。调用它可以返回一个指向当前对象的 std::shared_ptr，前提是当前对象已经被一个 std::shared_ptr 管理。
   - 如果对象不是由 std::shared_ptr 管理的（例如，直接在栈上创建或通过普通指针 new 创建），调用 shared_from_this() 会导致未定义行为（通常是抛出 std::bad_weak_ptr 异常）。

### 原理

- 当一个对象通过 std::make_shared 或 std::shared_ptr 的构造函数被首次管理时，std::enable_shared_from_this 的内部机制会自动将对象的控制块与一个 std::weak_ptr 关联起来。
- 当你调用 shared_from_this() 时，它会尝试将内部的 std::weak_ptr 升级为 std::shared_ptr。如果升级成功，说明对象仍然被 std::shared_ptr 管理，返回的 std::shared_ptr 会增加引用计数；如果失败（例如，对象已经被销毁），则会抛出异常。

### 场景

比如定时器回调，要打印日志，但是不保证调用回调的时候还有这个对象。所以用shared_from_this

## 危险用法

```cpp
class MyClass : public std::enable_shared_from_this<MyClass> {
public:
    void doWork() {
        // 正确方式：从this获取shared_ptr
        auto self = shared_from_this();
        // 传递给异步操作等...
    }
    
    std::shared_ptr<MyClass> getPtr() {
        return shared_from_this();
    }
};

// 使用
auto obj = std::make_shared<MyClass>();
obj->doWork();  // 安全！
```

