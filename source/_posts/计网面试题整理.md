---
title: 计网面试题整理
date: 2025-10-12 19:29:57
categories: cn
---

# HTTP请求完整过程

1. DNS域名解析

   **详细过程（递归查询 + 迭代查询）：**

   1. **浏览器缓存**：浏览器首先检查自己的缓存中是否有该域名的IP记录。
   2. **操作系统缓存**：如果浏览器缓存没有，浏览器会调用系统调用（如 `gethostbyname`），检查操作系统的Hosts文件和缓存。
   3. **路由器缓存**：请求会发送到本地路由器，路由器也可能缓存了DNS信息。
   4. **ISP的DNS服务器**：如果以上都没有，请求会发送到互联网服务提供商（ISP）的DNS服务器（也称为本地DNS服务器）。这是**递归查询**的开始，本地DNS服务器会负责帮我们找到答案。
   5. **根域名服务器**：本地DNS服务器首先询问根域名服务器（`.`）。根服务器不解析具体域名，但它会返回负责 `.com` 顶级域的顶级域名服务器的地址。
   6. **顶级域名服务器**：本地DNS服务器接着询问 `.com` 顶级域名服务器。该服务器返回负责 `baidu.com` 的权威域名服务器的地址。
   7. **权威域名服务器**：本地DNS服务器最后询问 `baidu.com` 的权威域名服务器。该服务器返回 `www.baidu.com` 的真正IP地址。
   8. **缓存并返回**：本地DNS服务器收到IP后，会将其缓存起来（根据TTL值），然后将结果返回给操作系统，再最终返回给浏览器。

2. 建立TCP连接

   拿到IP地址后，浏览器会通过操作系统协议栈，选择一个随机的源端口（例如 50000），向目标服务器的80端口（HTTP）或443端口（HTTPS）发起TCP连接。

   **经典的三次握手：**

   1. **SYN**： 客户端发送一个SYN=1的TCP报文，序列号为随机数 `seq = J`，表示请求建立连接。
   2. **SYN-ACK**： 服务器收到后，如果同意连接，会回复一个SYN=1和ACK=1的报文。确认号为 `ack = J+1`，同时自己也选择一个随机序列号 `seq = K`。
   3. **ACK**： 客户端收到服务器的回复后，再发送一个ACK=1的报文。确认号为 `ack = K+1`，序列号为 `seq = J+1`。

   至此，连接建立。双方确认了彼此的**发送和接收能力是正常的**。

3. 发起HTTP/HTTPS请求

   连接建立后，浏览器就可以发送HTTP请求了。

   **对于HTTPS（更常见的情况），还需要额外的步骤：**

   1. **TLS握手**：在HTTP通信开始前，先进行TLS握手，建立安全加密通道。

      - **Client Hello**： 客户端向服务器发送支持的TLS版本、加密套件列表和一个随机数。
      - **Server Hello**： 服务器选择TLS版本和加密套件，并发送自己的数字证书和一个随机数。
      - **验证证书**： 客户端验证服务器证书的合法性（是否由可信CA签发，域名是否匹配，是否在有效期内）。
      - **生成会话密钥**： 客户端用证书中的公钥加密一个预备主密钥发送给服务器。
      - **生成会话密钥**： 服务器用私钥解密后，双方利用三个随机数（客户端、服务器、预备主密钥）生成相同的对称会话密钥。
      - **加密通信**： 后续的HTTP通信将使用这个对称密钥进行加密。

   2. **发送HTTP请求报文**：

      http

      ```
      GET / HTTP/1.1
      Host: www.baidu.com
      Connection: keep-alive
      User-Agent: Mozilla/5.0...
      Accept: text/html,application/xhtml+xml...
      Accept-Encoding: gzip, deflate, br
      Cookie: ... （如果有之前存储的Cookie，会一并发送）
      ```

      

      - 请求行：方法（GET/POST）、URL路径、协议版本。
      - 请求头：包含大量元信息，如主机、浏览器类型、可接受的压缩格式等。
      - 请求体：对于GET请求通常为空，POST请求则包含提交的数据。

4. 传输层封装

   **封装报文段**：将HTTP请求报文作为**数据**，在前面加上**TCP头**。

   - **TCP头关键信息**：
     - **源端口**、**目标端口**（如80）：让服务器知道这个请求要交给哪个进程（如Nginx）。
     - **序列号**：保证数据包的有序性。
     - **确认号**：用于可靠传输的确认机制。
     - **窗口大小**：用于流量控制。

   此时，数据包变成了 **TCP报文段**。

5. 网络层封装

   **封装IP数据报**：将TCP报文段作为**数据**，在前面加上**IP头**。

   - **IP头关键信息**：
     - **源IP地址**：你的电脑的公网IP（经过NAT转换后）。
     - **目标IP地址**：`www.baidu.com` 的服务器IP（如 `14.215.177.39`）。
     - **TTL**：生存时间，每经过一个路由器减1，防止数据包在网络中无限循环。

   此时，数据包变成了 **IP数据报**。

   **路径选择**：根据目标IP地址，操作系统通过**路由表**确定这个数据包应该发送给哪个**网关**（通常是你的家庭路由器的IP）。

6. 数据链路层物理层封装

   **封装以太网帧**：将IP数据报作为**数据**，在前面加上**以太网帧头**，在后面加上**帧尾**。

   - **帧头关键信息**：
     - **目标MAC地址**：下一跳设备的MAC地址。在发送前，需要通过**ARP协议**查询到网关路由器接口的MAC地址。
     - **源MAC地址**：你电脑的网卡MAC地址。
     - **类型**：0x0800，表示帧内封装的是IP协议的数据。

   此时，数据包变成了 **以太网帧**。

   **物理层传输**：网卡驱动程序将以太网帧转换成**高低电压（有线）或无线电波（无线）**，通过物理介质发送出去。

7. 在互联网发送（通过路由器）

   1. 你的家庭路由器收到以太网帧后，**解封装**，去掉以太网帧头帧尾，得到IP数据报。
   2. 路由器检查目标IP地址，发现不是发给自己的，于是查找自己的**路由表**，决定下一个出口（比如你的ISP的某个路由接口）。
   3. 路由器将IP数据报**重新封装**成新的以太网帧（或PPP帧等），这个新帧的**源MAC地址**是路由器出口的MAC地址，**目标MAC地址**是下一跳路由器的MAC地址。
   4. 这个过程在网络中会重复多次，数据包经过一个个路由器（跳点），**IP地址不变，但MAC地址在每一跳都在改变**，直到最终到达目标服务器所在的网络。

8. 服务器处理请求并返回响应

   1. **Web服务器处理**：服务器（如Nginx）接收到请求，根据配置将请求转发给后端的应用服务器（如Tomcat, uWSGI）或直接返回静态文件。

   2. **应用服务器处理**：应用服务器（如运行着百度搜索逻辑的程序）处理业务，可能查询数据库、调用缓存、进行运算等。

   3. **返回HTTP响应**：

      http

      ```
      HTTP/1.1 200 OK
      Content-Type: text/html; charset=utf-8
      Content-Encoding: gzip
      Set-Cookie: ... （可能需要设置新的Cookie）
      Cache-Control: ... （缓存控制）
      
      <!DOCTYPE html>... （经过gzip压缩的HTML内容）
      ```

      

      - 状态行：状态码（200 OK, 404 Not Found等）。
      - 响应头：内容类型、编码、Cookie、缓存指令等。
      - 响应体：请求的真正资源，通常是HTML文档。

9. 浏览器前端解析

10. 断开TCP连接

    当页面加载完成，且不需要保持长连接时，TCP连接会关闭。

    **经典的四次挥手：**

    1. **FIN**： 客户端（主动关闭方）发送FIN=1的报文，表示自己没有数据要发送了。
    2. **ACK**： 服务器收到FIN后，回复一个ACK进行确认。此时，从客户端到服务器的连接关闭。
    3. **FIN**： 服务器处理完所有数据后，也发送一个FIN=1的报文给客户端，表示服务器也没有数据要发送了。
    4. **ACK**： 客户端收到服务器的FIN后，回复一个ACK进行确认。等待一段时间（2MSL，Maximum Segment Lifetime）后，连接彻底关闭。

# I/O多路复用三种方法的比较

- | 特性                  | select               | poll                 | epoll (Linux) / kqueue (BSD)     |
  | :-------------------- | :------------------- | :------------------- | :------------------------------- |
  | **底层机制**          | 轮询所有fd           | 轮询所有fd           | 回调函数，事件驱动               |
  | **最大连接数**        | 有限制 (通常1024)    | 无限制               | 无限制                           |
  | **效率**              | 连接数增加时线性下降 | 连接数增加时线性下降 | 连接数增加时无明显下降           |
  | **工作模式**          | 仅水平触发(LT)       | 仅水平触发(LT)       | 支持边缘触发(ET)和水平触发(LT)   |
  | **内核态-用户态拷贝** | 每次调用都拷贝fd集合 | 每次调用都拷贝fd集合 | 使用内存映射(mmap)，只需拷贝一次 |

- **面试回答要点：**

- **核心区别**：`select/poll` 是 **“轮询”** 机制，每次调用都需要将所有监听的文件描述符从用户态拷贝到内核态，并由内核进行线性扫描。`epoll` 是 **“事件回调”** 机制，内核维护一个事件表，只返回就绪的事件，效率更高。

- **水平触发 vs 边缘触发**：

  - **LT**：只要文件描述符处于就绪状态（如读缓冲区非空），每次调用 `epoll_wait` 都会通知你。编程更简单，不容易遗漏事件。
  - **ET**：只有当文件描述符状态发生变化时（如从不可读变为可读），才会通知一次。效率更高，但要求程序员必须一次性将数据读完/写完，否则会丢失事件。

- **ET模式如何避免丢事件**：

  - 必须使用**非阻塞IO**。
  - 在读取时，必须**循环读取**，直到返回 `EAGAIN` 或 `EWOULDBLOCK` 错误，确保将本次可读的数据全部读完。

# TCP粘包/拆包问题

**问题根源**：TCP是面向字节流的协议，没有消息边界。它只保证数据的有序和可靠，不保证应用层数据包的完整性。

**解决方案（定义应用层协议）：**

1. **定长消息**：每个消息都是固定长度。简单，但不够灵活，可能浪费带宽。
2. **分隔符**：在每个消息末尾加上特殊分隔符（如 `\r\n`）。需要转义机制。
3. **长度字段 + 消息体**：这是最常用、最有效的方法。
   - 在消息头中定义一个固定长度的字段，用来表示消息体的长度。
   - 接收方先读取固定长度的头，解析出消息体长度，再读取指定长度的数据。

# 大量TIME_WAIT状态

**产生原因**：**主动关闭连接的一方**会进入 `TIME_WAIT` 状态，持续 **2MSL**（报文最大生存时间，通常为60秒）。它的作用是：

- 可靠地终止TCP连接（确保最后的ACK能到达）。
- 让旧连接的重复报文在网络中消逝，避免被新连接错误接收。

**服务器端出现大量TIME_WAIT的影响**：耗尽本地端口资源，无法建立新的对外连接。

**解决方案**：

1. **首选：优化应用设计**
   - 使用**长连接**（如HTTP Keep-Alive，数据库连接池），避免频繁创建和关闭短连接。
   - 将关闭连接的主动权交给客户端（让客户端进入 `TIME_WAIT`）。
2. 如果是客户端突然断电
   - **应用层心跳**
     - 在应用层自己实现一个心跳协议，比如客户端每30秒发送一个“PING”消息，服务端回复“PONG”。
     - 如果服务端连续几次没收到心跳，就主动断开连接。这种方式更及时、更灵活。

# 大文件传输为什么选tcp

1. 可靠性

   UDP不保证数据一定到达，也不保证顺序，任何一个字节的丢失或者错序都会导致文件损坏

2. 流量控制

   TCP的滑动窗口机制能根据接收方的处理能力动态调整发送速率，防止快发送方淹没慢接收方

3. 拥塞控制

   TCP能感知网络拥堵并主动降低发送速率，保证整个网络的稳定，避免“网络风暴”。

