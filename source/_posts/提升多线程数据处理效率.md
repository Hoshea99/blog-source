---
title: 提升多线程数据处理效率
date: 2025-10-29 11:14:04
categories: cpp
---

**如何通过无锁队列（Lock-Free Queue）和SIMD指令集提升多线程数据处理效率？**

<!--more-->

# 核心问题

## 总体思路

提升多线程数据处理效率核心主要在两点：

1. 减少等待：最小化线程间因资源竞争导致的阻塞和上下文切换
2. 提升单次操作的数据吞吐量：让CPU在单个时钟周期内处理尽可能多的数据

无锁队列主要解决第一点：减少等待；而SIMD则解决第二点，提升吞吐量。

## 无锁队列

在多线程编程中，传统队列通常使用互斥锁来保证线程安全。当多个线程同时入队或者出队时，会发生锁竞争，导致线程被挂起，调度，产生大量的上下文切换开销。

**无锁队列通过原子操作来实现线程安全，优势如下：**

1. 非阻塞性：一个线程的执行失败不会导致他被挂起，而是立即重试或者进行其他工作
2. 可伸缩性：随着线程数量增加，无锁队列性能衰减小于有锁队列
3. 避免死锁：不使用锁，避免了死锁

## SIMD指令集

SIMD允许CPU用一个指令同时处理多个数据。例如，SSE指令集可以一次处理4个32位浮点数，AVX/AVX2可以一次处理8个32位浮点数。

**它的优势在于：**

1. 数据级并行：将循环或批量数据处理操作向量化。例如，对一个数组的所有元素加上一个常数，使用SIMD可以将操作次数减少为原来的1/4或1/8。
2. 隐藏内存延迟：虽然一次加载多个数据，但内存访问的延迟是类似的，有效提升了内存带宽利用率。
3. 提升指令效率：减少了循环控制和解码指令的开销

**在消费者线程内的应用：**

当消费者线程从无锁队列中取出一批数据（例如，一个包含大量数值的数组）后，真正的计算工作才开始。

1. 标量计算：使用常规指令，用循环逐个处理数组中的元素。
2. SIMD计算：将数组中的数据“打包”到SIMD寄存器中，使用一条指令同时处理多个元素。这直接将计算吞吐量提升了数倍。

简单来说，SIMD让每个CPU核心的“数据处理能力”实现了最大化。

# 原子操作介绍

在上一节我们讲到无锁队列用到了原子操作，我们这里简要介绍一下原子操作的概念与基本操作。

## memory_order

C++的memory_order共有六种枚举值，从弱到强进行说明：

1. memory_order_relaxed

   只保证了原子操作的原子性，不提供线程间的同步顺序约束：

   ```cpp
   std::atomic<int> x(0);
   
   x.store(42,std::memory_order_relaxed);
   
   int value = x.load(std::memory_order_relaxed); 
   ```

   其中，load读到的值可能是旧值或者是新值，无法保证同步。

2. memory_order_consume

   用的很少，这里不介绍了

3. memory_order_acquire

   用于读操作，效果为后续的读写操作不会重排到该acquire操作之前；与另一个线程的release写操作配对，形成同步关系

4. memory_order_release

   用于写操作，之前的读写操作不会重排到release之后

5. memory_order_acq_rel

   用于读改写操作，比如fetch_add操作

6. memory_order_seq_cst

   最严格

## 应用从`atomic<int>count`讲起

1. 把count想象成队列的物品数量

2. 生产者线程一直生产一个物品，然后让count+1

3. 消费者线程不断检查count，如果count>0，就消费一个物品，然后让count-1

   ```cpp
   //生产者代码逻辑：
   
   //在内存中准备物品（比如，data = 42; // 这不是原子操作）
   count.fetch_add(1, memory_order_relaxed); // 原子地增加计数
   //消费者代码逻辑：
   
   int c = count.load(memory_order_relaxed);
   //如果 c > 0，则开始消费 data。
   ```

**由于指令重排，生产者的步骤1，2可能会顺序颠倒，即消费者读取data的时候，可能data还没有被复制。读到了一个垃圾值**

因此要使用memory_order_acquire、memory_order_release

## 真正的无锁队列示例

本队列省略了很多边界条件处理，但是示范了核心思想

```cpp
#include <atomic>
#include <iostream>

// 队列节点
struct Node {
    int value;
    Node* next;
    Node(int val) : value(val), next(nullptr) {}
};

class SimpleLockFreeQueue {
private:
    // 原子指针：队头和队尾
    std::atomic<Node*> head;
    std::atomic<Node*> tail;

public:
    SimpleLockFreeQueue() {
        // 初始化时创建一个哑节点（dummy node），使逻辑更简单
        Node* dummy = new Node(0);
        head.store(dummy);
        tail.store(dummy);
    }

    // 生产者：入队
    void enqueue(int value) {
        Node* new_node = new Node(value);
        Node* current_tail = nullptr;
        Node* next_after_tail = nullptr;

        while (true) {
            // 1. 读取当前尾指针和它指向的节点的next指针
            current_tail = tail.load(std::memory_order_acquire);
            next_after_tail = current_tail->next; // 注意：这里需要确保current_tail有效

            // 2. 检查tail是否被其他线程移动了（关键检查！）
            if (current_tail != tail.load(std::memory_order_relaxed)) {
                continue; // 如果被移动了，重试
            }

            // 3. 如果tail->next不为空，说明有线程已经添加了节点但还没更新tail，帮忙推进
            if (next_after_tail != nullptr) {
                tail.compare_exchange_weak(current_tail, next_after_tail, 
                                         std::memory_order_release);
                continue; // 推进后重试
            }

            // 4. 核心CAS：尝试将当前尾节点的next指向新节点
            //    如果成功，说明我们抢到了添加权
            if (std::atomic_compare_exchange_weak_explicit(
                &(current_tail->next), &next_after_tail, new_node,
                std::memory_order_release, std::memory_order_relaxed)) {
                break; // 添加成功，退出循环
            }
        }

        // 5. 尝试更新tail指针到新节点（即使失败也没关系，其他线程会帮忙推进）
        tail.compare_exchange_weak(current_tail, new_node, 
                                 std::memory_order_release);
    }

    // 消费者：出队
    bool dequeue(int& value) {
        Node* current_head = nullptr;
        Node* current_tail = nullptr;
        Node* next_after_head = nullptr;

        while (true) {
            // 1. 读取头、尾、头节点的下一个节点
            current_head = head.load(std::memory_order_acquire);
            current_tail = tail.load(std::memory_order_acquire);
            next_after_head = current_head->next;

            // 2. 检查head是否被其他线程移动了
            if (current_head != head.load(std::memory_order_relaxed)) {
                continue;
            }

            // 3. 判断队列是否为空
            if (current_head == current_tail) {
                if (next_after_head == nullptr) {
                    return false; // 队列为空
                }
                // 有节点但tail没更新，帮忙推进tail
                tail.compare_exchange_weak(current_tail, next_after_head, 
                                         std::memory_order_release);
            } else {
                // 4. 队列非空，读取值
                value = next_after_head->value;
                
                // 5. 核心CAS：尝试将head移动到下一个节点
                if (head.compare_exchange_weak(current_head, next_after_head, 
                                             std::memory_order_release)) {
                    break; // 出队成功
                }
            }
        }
        
        // 6. 释放旧的头节点（实际生产环境需要更复杂的内存管理）
        delete current_head;
        return true;
    }
};

// 测试代码
int main() {
    SimpleLockFreeQueue queue;
    
    // 生产者线程（简化为顺序执行）
    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);
    
    // 消费者线程
    int value;
    while (queue.dequeue(value)) {
        std::cout << "Dequeued: " << value << std::endl;
    }
    
    return 0;
}
```

分析生产者函数，第一步先获取尾指针和指向节点的next指针，第二步需要检查尾指针是否已经被移动，如果已经被移动，就重试，第三部检查next指针是否为空，不为空说明还没有更新节点，就使用`compare_exchange_weak`函数进行帮忙推进。为空的话，就尝试指向新节点，添加成功后可以退出循环并尝试更新tail指针。

消费者函数也对应操作。

其中，最重要的接口就是CAS操作：`compare_exchange_weak`函数。

## `compare_exchange_weak`

`bool compare_exchange_weak(T& expected, T desired, std::memory_order order = std::memory_order_seq_cst);`

这个函数是C++无锁编程中最重要的函数，它的作用是如果当前大门上号码牌等于我预期的号码（expected）,则替换为desired，并返回true，否则把*this的内容写进expected，返回false。



代码中还出现了`atomic_compare_exchange_weak_explicit`函数，是因为大模型生成代码出混淆了，虽然不影响运行，其实也可以用上面那个版本的。这个函数其实核心逻辑和之前讲解的一样，只是参数传递方式不一样。

```cpp
_Bool atomic_compare_exchange_weak_explicit(
    volatile A* obj, 
    C* expected, 
    C desired, 
    memory_order succ, 
    memory_order fail);
```

> 参数解释：
>
> obj：指向原子变量的指针（如 atomic_int*）。
> expected：指向预期值的指针。这是一个指针，这是与C++版本最大的区别！
> desired：期望设置的新值。
> succ：成功时使用的内存序（当比较相等时）。
> fail：失败时使用的内存序（当比较不相等时）。





























