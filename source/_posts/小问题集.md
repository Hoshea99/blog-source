---
title: 小问题集
date: 2025-10-11 11:29:57
categories: cpp
---

# 拷贝构造函数的参数使用非引用，会造成什么后果？

会造成循环拷贝，因为为了调用拷贝构造函数，需要先创建参数other，创建other时又需要调用拷贝构造函数。

# 重载函数的返回类型可以不同吗？

可以，但是前提是参数列表必须不同。

# 如何解决引用头文件重复问题？

```cpp
#pragma once


//或者
#ifndef UTILS_H
#define UTILS_H

#endif
```

# 1G的内存排序1T的文件，文件内全是一行一个int

K路归并排序，先分成多个文件，每个文件里面1个g去排序。
然后合并，每次每个文件出一个值排序。

# 在析构函数中调用虚函数有什么问题

派生类可能已经析构，基类在析构函数里调用的虚函数可能是基类版本的，而不是派生类版本的。

# map和unordered_map两者区别

- map底层用到红黑树，unordered_map用到哈希表
- map有排序默认`<`，umap没有排序
- 时间复杂度 map是O(logn),umap是O(1),最坏O(N)哈希冲突时

## umap底层如何实现？

桶+哈希。桶即动态分配的数组，而每个桶内部存一个链表，用于处理哈希冲突。

## 除了链表，还有什么方法吗？

- 开放寻址法  
    【线性探测】如果被占用，就依次检查i+1/i+2...
    【二次探测】若i被占用，则找【i+1^2】/【i+2^2】...

# 构造和析构函数可以抛出异常吗？

构造函数可以，然后会逆序析构已经new出来的资源。  
析构函数不推荐，因为C++11之后默认为noexcept，如果抛出异常会直接崩溃。

```cpp
#include <iostream>
#include <stdexcept>

struct Resource {
    ~Resource() {
        std::cout << "析构中...\n";
        throw std::runtime_error("析构时出错！"); // ⚠️ 禁止这样做！
    }
};

int main() {
    try {
        Resource res;
    } catch (...) {
        std::cout << "捕获异常\n";
    }
    return 0;
}
```

如上，抛出异常是不会进入catch的。

# 程序的内存分区

```plain
高地址
+----------------------+
|      ...             |
|   命令行参数和环境变量 |
+----------------------+ <-- 栈顶 (esp寄存器指向这里)
|        栈            |  | (向下增长)
|                      |  |
|         ...          |  |
|                      |  |
+----------------------+ <-- 堆顶 (brk指针指向这里)
|                      |  |
|        堆            |  | (向上增长)
|                      |  |
+----------------------+
|         BSS          | (未初始化数据)
+----------------------+
|         Data         | (已初始化数据)
+----------------------+
|         Text         | (代码)
低地址
```

# free只传了个指针，如何知道传多大的空间

内存管理器在分配内存时，会额外分配一小块“簿记”区域来记录这块内存的信息（包括大小），而返回给你的指针，指向的是“簿记”区域之后的可使用空间。

这个区域的具体大小由C运行时库控制。
