---
title: 通信网关
date: 2025-10-17 09:17:51
categories: proj
---

# 系统概述

本系统为一个工业通信网关系统，用于连接和管理多种工业设备，实现跨协议的数据采集和转发。采用分层架构设计，模块松耦合，支持热插拔和动态扩展。

<!-- more-->

## 系统架构分层

[UI] --> [SDK] --> [代理层线程] --> [框架层] --> [模块基类] --> [PLC实现]

[SDK] <-- [代理层返回数据]

[模块管理类] --观察者--> [模块Node]  生命周期统一管理

# 核心技术实现

## 设计模式应用

| 模式       | 应用场景         | 说明                                                         |
| ---------- | ---------------- | ------------------------------------------------------------ |
| 工厂模式   | PLC品牌扩展      | 支持 Beckhoff、Keyence、Siemens 等厂商，新增品牌无需修改工厂类。 |
| 策略模式   | 数据发送策略     | 支持 单次、批量、字符串、整型 等策略，可动态切换。           |
| 代理模式   | SDK与框架隔离    | 隐藏200+框架接口，统一处理异常，提升安全性。                 |
| 观察者模式 | 模块生命周期管理 | 模块删除时，自动卸载其关联线程与资源。                       |

## 关键机制

- 多线程代理层：独立线程处理请求路由，使用有界队列避免消息堆积
- 动态加载机制：通过模块库管理类单例加载DLL，调用标准`__stdcall`接口创建模块实例
- 心跳管理机制：使用统一线程池轮询多模块，避免重复创建线程，提升性能

# 性能优化策略

| 优化项       |                                        |
| ------------ | -------------------------------------- |
| 通信超时控制 | 通信库中设置毫秒级超时，防止线程阻塞   |
| 资源回收     | 模块销毁时自动清理Node指针与关联线程   |
| 内存管理     | 使用智能指针管理模块实例，防止内存泄漏 |

# 安全设计

- 通信安全：代理层对SDK请求进行校验和过滤
- 接口隔离：代理层隐藏框架接口，仅暴露sdk接口
- 协议加固：手动实现PLC协议交互，不依赖厂商DLL，报文严格校验，连接前主动验证

# 模块生命周期管理流程

1. UI 操作：用户点击“添加模块”按钮，选择“西门子 S7”，点击确认。
2. SDK 层：
   1. 调用 SDK 提供的接口：XXX_增加模块()。
   2. 封装为 JSON 报文，通过通信库 write() 发送给代理层。
3. 代理层（独立线程）：
   1. 通过 read() 接收 JSON 报文。
   2. 解析报文，识别为“添加模块”请求。
   3. 调用框架层的“添加模块”接口。
4. 框架层：
   1. 模块资源管理类单例调用 addModule()。
   2. 动态加载对应 DLL，创建模块实例（继承自模块基类）。
   3. 将模块信息封装为 Node 指针，存入 vector<pair> 中。
5. 响应返回：
   1. 代理重新组装响应报文，通过通信库返回 SDK。

# 多线程与并发管理

- 代理层独立线程

  负责接收SDK请求并分发，避免阻塞UI

- 轮询任务处理

  使用同一线程池，一个线程处理多个轮询任务，避免重复创建

- 消息队列机制

  SDK为生产者，代理线程为消费者

  使用有界队列防止消息堆积，超量时丢弃旧消息

# 常见问题

## 工厂模式如何支持新PLC扩展

工厂类无需修改，新增PLC类集成模块基类注册即可

## 策略模式如何切换发送策略

运行时根据策略对象动态调用sendSingleData。sendString等方法

## 读取是否会阻塞导致堆积

通信库设置超时机制，超时则返回

## 一个模块多个轮询会重复启动线程吗

不会，统一使用线程池中的线程管理

## 模块销毁时是否会自动停止线程

会，通过观察者模式通知心跳与任务管理类主动卸载线程

## 代理层如何避免信息堆积

有界队列控制最大消息数量，防止资源耗尽

# 宽泛问题

## 这个系统为什么采用分层架构？

1. 关注点分离 (Separation of Concerns)：将系统划分为不同的层，每一层专注于特定的功能。

   1. C# UI层：专注于用户交互和界面展示。

   2. SDK层：为上层（UI）提供统一、简化的接口，屏蔽底层复杂性。

   3. 代理层：负责请求的转发、路由、线程隔离和初步处理（如校验、过滤）。

   4. 框架层：提供模块管理、生命周期管理、核心流程控制等基础功能。

   5. 模块基类/PLC实现层：专注于具体的通信协议实现（如与西门子、欧姆龙等PLC的交互）。

      这种分离使得开发、维护和理解系统变得更加容易。

2. 模块化与可维护性 (Modularity & Maintainability)：各层相对独立，修改某一层的实现通常不会直接影响到其他层（只要接口保持不变）。例如，新增一个PLC品牌的支持（模块实现层）不需要改动UI或SDK层的核心代码（得益于工厂模式）。这大大提高了系统的可维护性。
3. 可扩展性 (Extensibility)：通过接口和抽象（如模块基类、策略接口），可以在不影响现有代码结构的情况下扩展功能。例如，通过动态库和工厂模式轻松添加新的PLC类型；通过策略模式在运行时切换数据发送方式。
4. 复用性 (Reusability)：某些层或组件可以在不同场景下复用。例如，代理层的线程模型、通信库、心跳管理等通用机制可以被多个模块复用。
5. 隔离与稳定性 (Isolation & Stability)：
   1. 代理层通过独立线程处理请求，隔离了UI线程，防止底层耗时操作（如网络通信）导致界面卡死。
   2. 代理模式隔离了SDK和框架层，SDK无需直接调用复杂的框架接口，框架的内部变化不会轻易波及SDK。
   3. 模块通过动态库加载，实现了热插拔，一个模块的异常理论上不会轻易影响其他模块或核心系统（理想情况下）。
6. 控制复杂性 (Managing Complexity)：将一个庞大的系统分解为多个更小、更易管理的部分，有助于控制整体复杂度。

## 为什么使用代理模式，仅仅为了隐藏接口吗

除了隐藏接口，还有如下功能：

1. 统一异常处理

   代理层可以捕获来自框架层的所有异常，在代理内部进行统一的处理（如记录日志、转换为SDK能理解的错误码、进行重试等），然后将处理后的结果（成功/失败状态、数据）返回给SDK。这样，SDK无需关心底层可能发生的复杂异常，只需处理代理返回的标准化结果即可，提高了系统的健壮性和SDK代码的简洁性。

2. 线程隔离与防止界面卡死

3. 请求校验，对参数合法性和权限进行过滤，阻止无效请求进入框架

## 遇到的最大困难是什么？怎么解决的？

### 解决方案：
最大的困难是模块热插拔过程中多线程安全和资源回收的问题。

**问题分析：**
- 模块在任意线程中被创建和销毁
- 模块销毁时，其他线程可能还在使用模块资源（socket、定时器等）
- 导致崩溃或内存泄漏

**解决方案：**
1. **引入观察者模式**：模块销毁时广播事件，通知所有注册线程清理相关资源
2. **智能指针管理**：使用 `shared_ptr` 管理模块实例，确保所有线程释放引用后才真正销毁
3. **状态管理机制**：实现模块状态管理（正在加载、运行中、销毁中），避免销毁过程中被其他线程使用

## 心跳管理是怎么设计的？线程怎么复用？

### 解决方案：
**设计架构：**
- 统一线程池处理所有模块的心跳任务
- 每个模块的心跳任务提交到线程池中执行

**线程复用机制：**
- 使用固定大小的线程池，避免频繁创建线程
- 心跳任务由空闲线程执行
- 模块只需注册心跳回调函数，系统自动按周期提交任务

**资源管理：**
- 模块删除时自动取消心跳注册
- 通知线程池停止执行相关任务
- 实现任务解耦和资源自动回收

## 为什么使用有界队列？容量如何确定？溢出怎么处理？

### 解决方案：
**使用有界队列的原因：**
- 防止代理层处理能力不足导致 SDK 层消息堆积
- 控制内存使用，避免无限增长

**容量确定方法：**
- 基于压测时的吞吐量和延迟要求
- 设定最大容忍的消息积压数（如 1000 条）

**溢出处理策略：**
- 超过容量时丢弃旧消息
- 消息优先级分类：
  - 高优先级：模块变更消息
  - 低优先级：轮询消息
- 确保关键操作不被丢弃

## 如果某个模块初始化失败，怎么避免影响整个系统？

### 解决方案：
**错误处理机制：**

1. **异常捕获**：通过代理层统一捕获异常并记录日志
2. **错误码返回**：返回明确错误码给 SDK 层
3. **超时控制**：对每个模块启动进行超时控制，避免卡死系统

**隔离策略：**
- 失败模块不加入全局模块列表
- 不影响其他模块正常运行
- 系统保持可用状态
