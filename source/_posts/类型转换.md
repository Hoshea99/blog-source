---
title: 类型转换
date: 2025-10-11 11:39:01
categories: cpp
---

# static_cast

## 适用范围

1. 基本类型转换
2. 继承关系转换
3. void*和其他类型指针转换
4. 明确的隐式转换

```CPP
// 基本类型转换
double d = 3.14;
int i = static_cast<int>(d);  // 3

// 上行转换（安全）
class Base {};
class Derived : public Base {};
Derived* d = new Derived();
Base* b = static_cast<Base*>(d);  // 安全的向上转换

// 下行转换（不安全，需谨慎）
Base* base = new Base();
Derived* derived = static_cast<Derived*>(base);  // 危险！未检查

// void* 转换
void* ptr = malloc(sizeof(int));
int* int_ptr = static_cast<int*>(ptr);
```

# dynamic_cast

## 适用范围

安全的下行转换，只能用于具有虚函数的类。

失败时会抛异常，或者返回空指针

```cpp
class Base {
public:
    virtual void func() {}  // 必须有虚函数
};

class Derived : public Base {
public:
    void derivedFunc() {}
};

// 安全的下行转换
Base* base = new Derived();
Derived* derived = dynamic_cast<Derived*>(base);
if(derived) {
    derived->derivedFunc();  // 安全调用
}

// 转换失败的情况
Base* base2 = new Base();
Derived* derived2 = dynamic_cast<Derived*>(base2);
// derived2 == nullptr

// 引用转换（失败时抛异常）
try {
    Base& base_ref = *base;
    Derived& derived_ref = dynamic_cast<Derived&>(base_ref);
} catch(const std::bad_cast& e) {
    // 转换失败
}
```

# const_cast

## 适用范围

添加或移除const

```cpp
// 移除const
const int value = 42;
int* modifiable = const_cast<int*>(&value);
*modifiable = 100;  // 未定义行为！原对象是const

// 正确使用场景
void legacyFunction(int* param) {
    // 旧C函数，不接受const参数
}

void modernFunction(const int* param) {
    legacyFunction(const_cast<int*>(param));  // 临时移除const
}

// 添加const
int mutable_value = 42;
const int* const_ptr = const_cast<const int*>(&mutable_value);
```

# reinterpret_cast

## 适用范围

低级位模式转换，不进行安全检查

```cpp
// 指针到整数
int value = 42;
uintptr_t addr = reinterpret_cast<uintptr_t>(&value);

// 整数到指针
void* ptr = reinterpret_cast<void*>(addr);

// 不相关类型指针转换
struct A { int x; };
struct B { double y; };
A a{42};
B* b = reinterpret_cast<B*>(&a);  // 危险！位模式重新解释

// 函数指针转换
void (*func_ptr)() = reinterpret_cast<void(*)()>(some_address);
```



