---
title: 进程与线程
date: 2025-10-11 22:02:00
categories: os
---

# 进程

## 基本概念

### 定义

进程是程序的一次执行过程，是系统进行资源分配和调度的一个独立单位

### 组成

程序段

数据段

进程控制块（PCB）

### PCB

他描述了进程的基本信息和运行状态

是进程存在的唯一标识

包含了进程ID，状态，优先级等信息

## 进程的状态和切换

- 常见五状态模型
  1. 创建
  2. 就绪
  3. 运行
  4. 阻塞
  5. 结束
- 状态转换场景
  1. 2->3：被调度器选中
  2. 3->2：时间片用完
  3. 3->4：等待IO，信号量等资源
  4. 4->2：资源就绪或者被唤醒

## 进程的上下文切换

### 定义

从一个进程切换到另一个进程执行的过程

### 切换内容

- 用户资源：虚拟内存，栈，全局变量
- 内核资源：内核栈，寄存器，PCB

### 触发场景

- 时间片耗尽
- 进程阻塞
- 更高优先级的进程就绪

## 进程的控制操作

### 进程创建

1. 分配唯一PCB
2. 分配资源（内存，文件）
3. 初始化PCB（状态，程序计数器等）
4. 将PCB插入就绪队列

### 进程终止

1. 根据ID找到PCB
2. 如果正在运行，立即终止（如果不在运行时，也是立即改为终止状态），释放CPU
3. 如果有子进程，交给init进程接管
4. 释放所有资源
5. 将PCB队列中删除

### 进程阻塞

1. 找到对应PCB
2. 保存现场，状态改为阻塞
3. 插入阻塞队列
4. 调度其他就绪进程

### 进程唤醒

1. 从阻塞队列找到PCB
2. 移除阻塞队列，状态改为就绪
3. 插入就绪队列等待调度

## 进程调度算法

注意，线程调度也会用到这些类似算法

### 非抢占

1. 先来先服务
2. 短作业优先
3. 高响应比优先

### 抢占

1. 时间片轮转
2. 最高优先级调度
3. 多级队列调度

## 死锁

### 死锁产生的四个必要条件

- **互斥**：资源只能被一个进程占用
- **占有并等待**：进程已持有资源，同时等待其他资源
- **不可抢占**：资源只能由持有者释放
- **循环等待**：进程之间形成资源等待环

### 死锁处理方式

- **预防**：破坏四个必要条件之一
- **避免**：银行家算法，动态检查资源分配状态
- **检测与恢复**：检测是否存在环路，并强制释放资源

### 同步问题

#### 哲学家就餐问题

- 多个哲学家竞争有限的叉子（资源）
- 解决方案：限制同时就餐人数、资源分级分配、使用信号量

#### 读者-写者问题

- 多个读者可同时读，写者必须独占
- 解决方案：读者优先、写者优先、公平调度

# 线程

## 基本定义

线程是操作系统能够进行运算调度的最小单位，他被包含在进程之中，是进程中实际运作单位。

- 线程是CPU调度和分配的基本单位
- 一个进程可以有一个或多个线程，他们共享进程的资源
- 每个线程有自己独立的线程ID，程序计数器

# 进程 vs 线程

| 维度         | 进程                                                     | 线程                                                 |
| :----------- | :------------------------------------------------------- | :--------------------------------------------------- |
| **资源拥有** | 资源分配的基本单位，拥有独立的地址空间、文件、信号等资源 | 不拥有系统资源，共享其所属进程的全部资源             |
| **调度单位** | 独立调度单位，由操作系统内核进行进程调度                 | 独立调度和分配的基本单位，由操作系统内核进行线程调度 |
| **系统开销** | 上下文切换需要切换内存地址空间，开销大（Cache、TLB失效） | 上下文切换仅需保存寄存器、栈等少量资源，开销小       |
| **通信方式** | 管道、消息队列、共享内存、信号量、信号、Socket等         | 读写同一进程的全局数据、互斥锁、条件变量、信号量等   |
| **健壮性**   | 一个进程崩溃不会影响其他进程                             | 一个线程崩溃会导致整个进程崩溃                       |
| **C++实现**  | `fork()`、`std::process` (C++20)                         | `std::thread`、`pthreads`                            |

# 常见问题

## 进程

### 普通问题

1. 什么是进程？和程序的区别？

   进程是执行中的程序，是动态的，程序是静态的代码集合

2. 进程拥有哪些状态，状态如何切换

3. 什么是上下文切换，开销在哪？

   切换进程时保存和恢复现场的过程，开销主要在寄存器，内存映射

### 项目问题

**1. 在C++高性能服务器中，为什么我们通常选择使用多线程而不是多进程？在什么场景下你会反其道而行之，选择多进程？**

- **选多线程**：因为线程间共享内存，**数据共享极其高效**（无需序列化、进程间通信），上下文切换开销小，非常适合用于处理同一任务的多个部分（如一个连接一个线程，共享监听socket和缓存）。
- **选多进程**：
  - **需要更好的隔离性和健壮性**。例如，一个处理用户请求的模块崩溃了，你不希望它把整个服务器拖垮。使用进程可以隔离这种故障。
  - **利用多机扩展**。进程模型更容易扩展到分布式系统。
  - **利用第三方库**。某些第三方库不是线程安全的，将其放在独立的进程中是最安全的用法。

**2. 在C++程序中，进程上下文切换具体会导致哪些我们需要注意的性能损耗？**

这远不止是“保存/恢复寄存器”那么简单。在工程上我们需要关注：

- **TLB（快表）失效**：切换内存地址空间意味着TLB大部分或全部需要刷新，导致后续内存访问需要多次内存查找，这是**最大的开销之一**。
- **CPU Cache失效**：新进程的数据和代码会“污染”当前CPU缓存，缓存命中率急剧下降。
- **调度器自身开销**：如果进程数非常多，调度器选择下一个进程的算法本身也会消耗CPU时间。

**3. 假设你写了一个C++程序，用 `fork()` 创建了子进程。在子进程中，如果一个文件描述符在父进程中被加锁（如 `flock`），子进程会继承这个锁吗？这可能导致什么工程问题？**

- **会继承**。在Linux中，子进程会继承父进程的文件描述符表，包括其上的锁状态。
- **工程问题**：这可能导致**难以调试的死锁**。例如，父进程锁了一个文件，子进程也试图去锁同一个文件（通过同一个文件描述符），在某些锁类型下，子进程可能会成功（递归锁）或阻塞，行为取决于具体实现和锁类型，容易造成逻辑混乱。**最佳实践**是 `fork()` 后，子进程应立即关闭不需要的文件描述符，或使用 `fcntl` 设置 `FD_CLOEXEC` 标志。

**4. 在Linux C++编程中，`fork()` 和 `exec()` 系列函数通常一起使用。请问在 `fork()` 之后，`exec()` 之前，子进程应该特别注意处理哪些资源？为什么？**

这是一个经典陷阱。在 `fork()` 后 `exec()` 前，子进程拥有父进程的完整副本。但 `exec()` 会用新程序替换当前进程的代码、数据、堆栈。因此必须注意：

- **关闭不需要的文件描述符**：否则会被新程序继承，可能导致资源泄漏或意外的文件访问。
- **处理信号**：继承的信号处理函数可能在新程序中不存在，导致未定义行为。通常需要在 `exec()` 前将信号重置为默认状态。
- **同步问题**：确保子进程不会和父进程在共享资源（如临时文件）上产生竞争。

## 线程

1. 一个线程意外崩溃会导致什么

   整个进程崩溃

2. 多线程编程中为什么要用到线程同步

   否则会导致数据竞争

3. 多线程程序一定能提高性能吗？

   不一定，当

   1. 线程数大于CPU核心数，频繁上下文切换
   2. 大量线程竞争同一把锁
   3. 缓存一致性协议

4. 什么是虚假唤醒，如何处理

   虚假唤醒指等待条件变量的线程可能在没被通知的情况下被唤醒

   处理方法为使用while循环检查，而不是if语句

   ```cpp
   std::unique_lock<std::mutex> lock(mutex);
   while (!condition) {
       cond_var.wait(lock);
   }
   ```

   
