---
title: 三/五/零法则
date: 2025-10-30 10:58:08
categories: cpp
---

这是一个 C++ 编程原则，用于正确管理资源（如动态内存、文件句柄等）。它规定了类在什么情况下需要定义哪些特殊的成员函数，以避免资源泄漏、重复释放等问题。

<!--more-->

# 三法则
**核心思想：如果一个类需要显式定义 析构函数、拷贝构造函数 或 拷贝赋值运算符 中的任何一个，那么它很可能需要同时显式定义全部三个。**

- 析构函数：负责在对象销毁时释放资源。
- 拷贝构造函数：用一个已存在的对象来初始化一个新对象。
- 拷贝赋值运算符：将一个已存在对象的值赋给另一个已存在的对象。

如果一个类管理着动态内存或其他资源（例如打开的文件），而你没有定义拷贝构造函数和拷贝赋值运算符，编译器会为你生成默认的版本。这些默认版本只是进行浅拷贝（逐成员复制），而浅拷贝会带来灾难性后果：

```cpp
#include <iostream>

class RuleOfThree {
private:
    int* data;
public:
    // 构造函数
    RuleOfThree(int value) : data(new int(value)) {
        std::cout << "构造函数调用\n";
    }

    // 析构函数 - 需要释放资源
    ~RuleOfThree() {
        std::cout << "析构函数调用，释放内存: " << *data << std::endl;
        delete data;
    }
    
    // 注意：我们没有定义拷贝构造函数和拷贝赋值运算符！
    // 编译器将使用默认的浅拷贝版本。

};

int main() {
    RuleOfThree obj1(10);

    {
        RuleOfThree obj2 = obj1; // 浅拷贝！obj2.data 和 obj1.data 指向同一块内存
    } // obj2 离开作用域，析构函数被调用，内存被释放！
    
    // 此时 obj1.data 已经是一个悬空指针！
    std::cout << "obj1 的值: " << *obj1.data << std::endl; // 未定义行为！可能崩溃或输出乱码
    
    return 0;

} // obj1 离开作用域，析构函数再次尝试释放同一块内存 -> 双重释放，程序崩溃！
```

解决方案：遵循三法则，定义所有三个函数。

```cpp
class RuleOfThree {
private:
    int* data;
public:
    // 构造函数
    RuleOfThree(int value) : data(new int(value)) {}

    // 1. 析构函数
    ~RuleOfThree() {
        delete data;
    }
    
    // 2. 拷贝构造函数（深拷贝）
    RuleOfThree(const RuleOfThree& other) : data(new int(*other.data)) {}
    
    // 3. 拷贝赋值运算符（深拷贝）
    RuleOfThree& operator=(const RuleOfThree& other) {
        if (this != &other) { // 防止自我赋值 (a = a)
            *data = *other.data; // 或者先 delete data; 再 data = new int(*other.data);
        }
        return *this;
    }

};
```

现在，拷贝操作会进行深拷贝，每个对象都拥有自己独立的资源，问题就解决了。

# 五法则

其实就是C++11后出现移动语义后三法则的更新版本，多了移动构造函数和 移动赋值函数

# 零法则

**核心思想：类的设计应该追求不需要自己定义任何特殊的成员函数（析构、拷贝/移动构造、拷贝/移动赋值）。**

通过将资源管理的职责完全委托给已有的、遵循了五法则的成员对象（如 std::string, std::vector, std::unique_ptr 等）。让编译器自动生成的默认版本就足够了，因为它们会正确地调用成员对象的相应函数。

```cpp
#include <vector>
#include <memory>

class RuleOfZero {
private:
    std::vector<int> data;        // 管理动态数组
    std::unique_ptr<int> ptr;     // 管理动态内存
    std::string name;             // 管理字符串

public:
    // 我们不需要定义任何以下函数：
    // ~RuleOfZero();                            // 编译器生成的析构函数会正确调用 data, ptr, name 的析构函数
    // RuleOfZero(const RuleOfZero&);            // 编译器生成的拷贝构造会调用成员的拷贝构造（深拷贝）
    // RuleOfZero& operator=(const RuleOfZero&); // 同上
    // RuleOfZero(RuleOfZero&&);                 // 编译器生成的移动构造会调用成员的移动构造（高效）
    // RuleOfZero& operator=(RuleOfZero&&);      // 同上

    // 只需要定义普通的构造函数
    RuleOfZero(std::vector<int> d, std::unique_ptr<int> p, std::string n)
        : data(std::move(d)), ptr(std::move(p)), name(std::move(n)) {}

};
```
