---
title: 存储系统
date: 2025-10-11 23:03:18
categories: os
---

# 存储器层次结构

## 存储金字塔

| 层级          | 存储介质               | 特点                     | 访问时间  | 容量 |
| :------------ | :--------------------- | :----------------------- | :-------- | :--- |
| **寄存器**    | CPU内部寄存器          | 速度极快，半时钟周期完成 | ~0.1ns    | KB级 |
| **CPU Cache** | SRAM（静态随机存储器） | 断电数据丢失，分L1/L2/L3 | ~1ns      | MB级 |
| **主内存**    | DRAM（动态随机存储器） | 需要刷新，速度较慢       | ~10-100ns | GB级 |
| **SSD**       | NAND Flash             | 非易失性，速度快于HDD    | ~10-100μs | TB级 |
| **HDD**       | 磁性盘片               | 机械寻道，速度最慢       | ~1-10ms   | TB级 |

**关键面试点：**

- **SRAM vs DRAM**：SRAM更快更贵，用于Cache；DRAM更便宜，用于主内存
- **访问时间差距**：CPU Cache比内存快10-100倍，内存比SSD快1000倍

# CPU Cache工作原理

## 层级

- **L1 Cache**：分指令Cache和数据Cache，每个核心独享
- **L2 Cache**：每个核心独享
- **L3 Cache**：所有核心共享

# 虚拟内存机制

## 为什么需要虚拟内存？

- **进程隔离**：每个进程有独立的地址空间
- **内存扩展**：程序可以使用比物理内存更大的地址空间
- **简化编程**：程序员无需关心物理内存布局

## 地址转换过程

```plain
虚拟地址 → [MMU] → 物理地址
              ↓
      页表（存储映射关系）
```

## 分段 vs 分页

| 方面         | 分段                         | 分页                     |
| :----------- | :--------------------------- | :----------------------- |
| **管理视角** | 逻辑视角（代码段、数据段等） | 物理视角（固定大小页面） |
| **划分单位** | 按逻辑单元大小划分           | 固定大小（通常4KB）      |
| **地址构成** | 段基址 + 段内偏移            | 页号 + 页内偏移          |
| **碎片问题** | 外部碎片严重                 | 内部碎片（页内浪费）     |
| **现代应用** | 较少使用                     | 现代操作系统主流         |

## 多级页表

- 解决单级页表空间开销大的问题
- 按需分配页表，节省内存
- 举例：x86-64使用4级页表

## 页面置换算法

### 最佳置换算法（OPT）

- 淘汰未来最长时间不会被访问的页面
- 理论最优，但无法实际实现（无法预知未来）

### 先进先出（FIFO）

```cpp
// 伪代码实现
queue page_queue;  // 页面队列

void access_page(int page_num) {
    if (!page_in_memory(page_num)) {
        if (memory_full()) {
            victim = page_queue.front();  // 淘汰最先进入的
            page_queue.pop();
            remove_page(victim);
        }
        page_queue.push(page_num);
        load_page(page_num);
    }
}
```



- **Belady异常**：分配更多页框时，缺页率反而上升

### 最近最久未使用（LRU）

cpp

```
// 伪代码实现
list page_list;  // 按访问时间排序

void access_page(int page_num) {
    if (page_in_memory(page_num)) {
        page_list.remove(page_num);  // 从原位置移除
    } else {
        if (memory_full()) {
            victim = page_list.back();  // 淘汰最久未使用的
            page_list.pop_back();
            remove_page(victim);
        }
        load_page(page_num);
    }
    page_list.push_front(page_num);  // 放到最近使用位置
}
```

- 实际近似实现：时钟算法、二次机会算法

# 面试题

## 概念题

1. 为什么需要多级Cache
   - 在速度和容量取得平衡
   - L1追求速度，L3追求容量
   - 降低平均内存访问时间
2. 虚拟内存的好处
3. 如何监控程序缺页情况？
   - Linux：`perf stat -e page-faults ./program`
   - Windows：性能监视器跟踪Page Faults/sec
